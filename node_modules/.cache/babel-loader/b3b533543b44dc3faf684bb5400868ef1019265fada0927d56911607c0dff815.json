{"ast":null,"code":"import * as THREE from 'three';\nimport gsap from 'gsap';\n// 城市模型材质修改\nexport default function modityCityMaterial(city) {\n  // 修改城市模型着色器\n  city.material.onBeforeCompile = shader => {\n    // 添加一个替换标识\n    shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', `#include <dithering_fragment>\n          // #end#\n          `);\n    // 城市混合颜色效果\n    addGradColor(city, shader);\n    // 光圈扩散\n    addSpread(shader);\n    // 斜光线扩散\n    addLightLine(shader);\n    // 从下向上扫描\n    addTopLine(shader);\n  };\n}\n// 1.城市混合颜色效果\nfunction addGradColor(city, shader) {\n  // 先计算\n  city.geometry.computeBoundingBox();\n  // 解构得到外边界矩形\n  let {\n    max,\n    min\n  } = city.geometry.boundingBox;\n  // 最高点减去最低点得到高度差\n  let uHeight = max.y - min.y;\n  // 最高点的颜色\n  shader.uniforms.uTopColor = {\n    value: new THREE.Color('#6699cc')\n  };\n\n  // 高度差\n  shader.uniforms.uHeight = {\n    value: uHeight\n  };\n  shader.vertexShader = shader.vertexShader.replace('#include <common>',\n  // 将顶点着色器的顶点传到片元着色器上\n  // 这里定义一个属性，片元着色器才能获取\n  `#include <common>\n      varying vec3 vPosition; \n    `);\n  shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>',\n  // 将顶点着色器的顶点传到片元着色器上\n  // 将顶点着色器的position传到common定义的varying vposition，这样在片元着色器能获取到顶点着色器的position\n  `#include <begin_vertex>\n      vPosition = position;\n      `);\n  shader.fragmentShader = shader.fragmentShader.replace('#include <common>',\n  // 将材质传入的变量定义，将顶点传入的数据定义\n  `#include <common>\n        uniform vec3 uTopColor;\n        uniform float uHeight;\n        varying vec3 vPosition;\n        `);\n  shader.fragmentShader = shader.fragmentShader.replace('// #end#',\n  // 定义一个将要混合成的颜色变量，将片元着色器的颜色传入\n  `\n        vec4 distGradColor = gl_FragColor;\n        // 设置混合百分比 uHeight 的差可能为负，所以永远为正 -84 + 84 必须等于 0 到 160   即 负除正等于 负乘正\n        float gradMix = (vPosition.y + uHeight / 2.0) / uHeight; // 从0到高度  即从0到100%\n        // 计算混合颜色\n        vec3 gradMixColor = mix(distGradColor.xyz, uTopColor, gradMix);\n        gl_FragColor = vec4(gradMixColor, 1);\n        // #end#\n        `);\n}\n\n// 2.扩散效果\nfunction addSpread(shader) {\n  // 传入扩散中心点\n  shader.uniforms.uSpreadCenter = {\n    value: new THREE.Vector2(0, 0)\n  };\n  // 传入扩散时间\n  shader.uniforms.uSpreadTime = {\n    value: 0\n  };\n  // 传入条纹的宽度\n  shader.uniforms.uSpreadWidth = {\n    value: 40\n  };\n  shader.fragmentShader = shader.fragmentShader.replace('#include <common>',\n  // 将材质传入的变量定义，将顶点传入的数据定义\n  `#include <common>\n        uniform vec2 uSpreadCenter;\n        uniform float uSpreadTime;\n        uniform float uSpreadWidth;\n        `);\n  shader.fragmentShader = shader.fragmentShader.replace('// #end#', `\n        // 获得顶点到中心，即半径\n        float spreadRadius = distance(vPosition.xz, uSpreadCenter);\n        // 扩散范围的函数 -x的平方\n        float spreadIndex = - (spreadRadius - uSpreadTime) * (spreadRadius - uSpreadTime) + uSpreadWidth;\n        \n\n        if(spreadIndex > 0.0) {\n          gl_FragColor = mix(gl_FragColor, vec4(1, 1, 1, 1), spreadIndex / uSpreadWidth);\n        }\n        // #end#\n        `);\n  // 利用动画来让时间不断改变\n  gsap.to(shader.uniforms.uSpreadTime, {\n    value: 600,\n    duration: 2,\n    ease: 'none',\n    repeat: -1\n  });\n}\n\n// 3.倾斜扫描效果\nfunction addLightLine(shader) {\n  // 传入扩散时间 使线段从角上开始掠过\n  shader.uniforms.uLightLineTime = {\n    value: -700\n  };\n  // 传入条纹的宽度\n  shader.uniforms.uLightLineWidth = {\n    value: 30\n  };\n  shader.fragmentShader = shader.fragmentShader.replace('#include <common>',\n  // 将材质传入的变量定义，将顶点传入的数据定义\n  `#include <common>\n        // uniform vec2 uSpreadCenter;\n        uniform float uLightLineTime;\n        uniform float uLightLineWidth;\n        `);\n  shader.fragmentShader = shader.fragmentShader.replace('// #end#', `\n        // 扩散范围的函数 -x的平方 vPosition.x竖  + vPosition.z斜\n        float lightLineIndex = - (vPosition.x + vPosition.z - uLightLineTime) * (vPosition.x + vPosition.z - uLightLineTime) + uLightLineWidth;\n        \n\n        if(lightLineIndex > 0.0) {\n          gl_FragColor = mix(gl_FragColor, vec4(1, 1, 1, 1), lightLineIndex / uLightLineWidth);\n        }\n        // #end#\n        `);\n  // 利用动画来让时间不断改变\n  gsap.to(shader.uniforms.uLightLineTime, {\n    value: 1000,\n    duration: 3,\n    ease: 'none',\n    repeat: -1\n  });\n}\n\n// 3.从下向上扫描效果\nfunction addTopLine(shader) {\n  // 传入扩散时间 使线段从角上开始掠过\n  shader.uniforms.uTopLineTime = {\n    value: -100\n  };\n  // 传入条纹的宽度\n  shader.uniforms.uTopLineWidth = {\n    value: 40\n  };\n  shader.fragmentShader = shader.fragmentShader.replace('#include <common>',\n  // 将材质传入的变量定义，将顶点传入的数据定义\n  `#include <common>\n        uniform float uTopLineTime;\n        uniform float uTopLineWidth;\n        `);\n  shader.fragmentShader = shader.fragmentShader.replace('// #end#', `\n        // 扩散范围的函数 -x的平方\n        float topLineIndex = - (vPosition.y - uTopLineTime) * (vPosition.y - uTopLineTime) + uTopLineWidth;\n        \n\n        if(topLineIndex > 0.0) {\n          gl_FragColor = mix(gl_FragColor, vec4(1, 1, 1, 1), topLineIndex / uTopLineWidth);\n        }\n        // #end#\n        `);\n  // 利用动画来让时间不断改变\n  gsap.to(shader.uniforms.uTopLineTime, {\n    value: 1000,\n    duration: 3,\n    ease: 'none',\n    repeat: -1\n  });\n}","map":{"version":3,"names":["THREE","gsap","modityCityMaterial","city","material","onBeforeCompile","shader","fragmentShader","replace","addGradColor","addSpread","addLightLine","addTopLine","geometry","computeBoundingBox","max","min","boundingBox","uHeight","y","uniforms","uTopColor","value","Color","vertexShader","uSpreadCenter","Vector2","uSpreadTime","uSpreadWidth","to","duration","ease","repeat","uLightLineTime","uLightLineWidth","uTopLineTime","uTopLineWidth"],"sources":["D:/vscodeDemo/threeDemo/threejs_smartcity/src/threeModal/modity/modityCityMaterial.js"],"sourcesContent":["import * as THREE from 'three'\r\nimport gsap from 'gsap'\r\n// 城市模型材质修改\r\nexport default function modityCityMaterial (city) {\r\n  \r\n  // 修改城市模型着色器\r\n  city.material.onBeforeCompile = shader => {\r\n    // 添加一个替换标识\r\n    shader.fragmentShader = shader.fragmentShader.replace(\r\n      '#include <dithering_fragment>',\r\n      `#include <dithering_fragment>\r\n          // #end#\r\n          `\r\n    )\r\n    // 城市混合颜色效果\r\n    addGradColor(city, shader)\r\n    // 光圈扩散\r\n    addSpread(shader)\r\n    // 斜光线扩散\r\n    addLightLine(shader)\r\n    // 从下向上扫描\r\n    addTopLine(shader)\r\n  }\r\n}\r\n// 1.城市混合颜色效果\r\nfunction addGradColor(city, shader) {\r\n  // 先计算\r\n  city.geometry.computeBoundingBox()\r\n  // 解构得到外边界矩形\r\n  let { max, min } = city.geometry.boundingBox\r\n  // 最高点减去最低点得到高度差\r\n  let uHeight = max.y - min.y\r\n  // 最高点的颜色\r\n  shader.uniforms.uTopColor = {value: new THREE.Color('#6699cc')}\r\n\r\n  // 高度差\r\n  shader.uniforms.uHeight = {value: uHeight}\r\n  shader.vertexShader = shader.vertexShader.replace(\r\n    '#include <common>', // 将顶点着色器的顶点传到片元着色器上\r\n    // 这里定义一个属性，片元着色器才能获取\r\n    `#include <common>\r\n      varying vec3 vPosition; \r\n    `\r\n  )\r\n  shader.vertexShader = shader.vertexShader.replace(\r\n    '#include <begin_vertex>', // 将顶点着色器的顶点传到片元着色器上\r\n    // 将顶点着色器的position传到common定义的varying vposition，这样在片元着色器能获取到顶点着色器的position\r\n    `#include <begin_vertex>\r\n      vPosition = position;\r\n      `\r\n  )\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '#include <common>',\r\n    // 将材质传入的变量定义，将顶点传入的数据定义\r\n    `#include <common>\r\n        uniform vec3 uTopColor;\r\n        uniform float uHeight;\r\n        varying vec3 vPosition;\r\n        `\r\n  )\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '// #end#',\r\n    // 定义一个将要混合成的颜色变量，将片元着色器的颜色传入\r\n    `\r\n        vec4 distGradColor = gl_FragColor;\r\n        // 设置混合百分比 uHeight 的差可能为负，所以永远为正 -84 + 84 必须等于 0 到 160   即 负除正等于 负乘正\r\n        float gradMix = (vPosition.y + uHeight / 2.0) / uHeight; // 从0到高度  即从0到100%\r\n        // 计算混合颜色\r\n        vec3 gradMixColor = mix(distGradColor.xyz, uTopColor, gradMix);\r\n        gl_FragColor = vec4(gradMixColor, 1);\r\n        // #end#\r\n        `\r\n  )\r\n}\r\n\r\n// 2.扩散效果\r\nfunction addSpread(shader) {\r\n  // 传入扩散中心点\r\n  shader.uniforms.uSpreadCenter = {value: new THREE.Vector2(0, 0)}\r\n  // 传入扩散时间\r\n  shader.uniforms.uSpreadTime = {value: 0}\r\n  // 传入条纹的宽度\r\n  shader.uniforms.uSpreadWidth = {value: 40}\r\n\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '#include <common>',\r\n    // 将材质传入的变量定义，将顶点传入的数据定义\r\n    `#include <common>\r\n        uniform vec2 uSpreadCenter;\r\n        uniform float uSpreadTime;\r\n        uniform float uSpreadWidth;\r\n        `\r\n  )\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '// #end#',\r\n    `\r\n        // 获得顶点到中心，即半径\r\n        float spreadRadius = distance(vPosition.xz, uSpreadCenter);\r\n        // 扩散范围的函数 -x的平方\r\n        float spreadIndex = - (spreadRadius - uSpreadTime) * (spreadRadius - uSpreadTime) + uSpreadWidth;\r\n        \r\n\r\n        if(spreadIndex > 0.0) {\r\n          gl_FragColor = mix(gl_FragColor, vec4(1, 1, 1, 1), spreadIndex / uSpreadWidth);\r\n        }\r\n        // #end#\r\n        `\r\n  )\r\n  // 利用动画来让时间不断改变\r\n  gsap.to(shader.uniforms.uSpreadTime, {\r\n    value: 600,\r\n    duration: 2,\r\n    ease: 'none',\r\n    repeat: -1\r\n  })\r\n}\r\n\r\n// 3.倾斜扫描效果\r\nfunction addLightLine(shader) {\r\n  // 传入扩散时间 使线段从角上开始掠过\r\n  shader.uniforms.uLightLineTime = {value: -700}\r\n  // 传入条纹的宽度\r\n  shader.uniforms.uLightLineWidth = {value: 30}\r\n\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '#include <common>',\r\n    // 将材质传入的变量定义，将顶点传入的数据定义\r\n    `#include <common>\r\n        // uniform vec2 uSpreadCenter;\r\n        uniform float uLightLineTime;\r\n        uniform float uLightLineWidth;\r\n        `\r\n  )\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '// #end#',\r\n    `\r\n        // 扩散范围的函数 -x的平方 vPosition.x竖  + vPosition.z斜\r\n        float lightLineIndex = - (vPosition.x + vPosition.z - uLightLineTime) * (vPosition.x + vPosition.z - uLightLineTime) + uLightLineWidth;\r\n        \r\n\r\n        if(lightLineIndex > 0.0) {\r\n          gl_FragColor = mix(gl_FragColor, vec4(1, 1, 1, 1), lightLineIndex / uLightLineWidth);\r\n        }\r\n        // #end#\r\n        `\r\n  )\r\n  // 利用动画来让时间不断改变\r\n  gsap.to(shader.uniforms.uLightLineTime, {\r\n    value: 1000,\r\n    duration: 3,\r\n    ease: 'none',\r\n    repeat: -1\r\n  })\r\n\r\n}\r\n\r\n// 3.从下向上扫描效果\r\nfunction addTopLine(shader) {\r\n  // 传入扩散时间 使线段从角上开始掠过\r\n  shader.uniforms.uTopLineTime = {value: -100}\r\n  // 传入条纹的宽度\r\n  shader.uniforms.uTopLineWidth = {value: 40}\r\n\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '#include <common>',\r\n    // 将材质传入的变量定义，将顶点传入的数据定义\r\n    `#include <common>\r\n        uniform float uTopLineTime;\r\n        uniform float uTopLineWidth;\r\n        `\r\n  )\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '// #end#',\r\n    `\r\n        // 扩散范围的函数 -x的平方\r\n        float topLineIndex = - (vPosition.y - uTopLineTime) * (vPosition.y - uTopLineTime) + uTopLineWidth;\r\n        \r\n\r\n        if(topLineIndex > 0.0) {\r\n          gl_FragColor = mix(gl_FragColor, vec4(1, 1, 1, 1), topLineIndex / uTopLineWidth);\r\n        }\r\n        // #end#\r\n        `\r\n  )\r\n  // 利用动画来让时间不断改变\r\n  gsap.to(shader.uniforms.uTopLineTime, {\r\n    value: 1000,\r\n    duration: 3,\r\n    ease: 'none',\r\n    repeat: -1\r\n  })\r\n\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}