{"ast":null,"code":"import * as THREE from 'three';\nimport gsap from 'gsap';\n// 城市模型材质修改\nexport default function modityCityMaterial(city) {\n  // 修改城市模型着色器\n  city.material.onBeforeCompile = shader => {\n    // 添加一个替换标识\n    shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', `#include <dithering_fragment>\n          // #end#\n          `);\n    // 城市混合颜色效果\n    addGradColor(city, shader);\n    // 光圈扩散\n    addSpread(shader);\n    // 斜光线扩散\n    addLightLine(shader);\n  };\n}\n// 1.城市混合颜色效果\nfunction addGradColor(city, shader) {\n  // 先计算\n  city.geometry.computeBoundingBox();\n  // 解构得到外边界矩形\n  let {\n    max,\n    min\n  } = city.geometry.boundingBox;\n  // 最高点减去最低点得到高度差\n  let uHeight = max.y - min.y;\n  // 最高点的颜色\n  shader.uniforms.uTopColor = {\n    value: new THREE.Color('#6699cc')\n  };\n\n  // 高度差\n  shader.uniforms.uHeight = {\n    value: uHeight\n  };\n  shader.vertexShader = shader.vertexShader.replace('#include <common>',\n  // 将顶点着色器的顶点传到片元着色器上\n  // 这里定义一个属性，片元着色器才能获取\n  `#include <common>\n      varying vec3 vPosition; \n    `);\n  shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>',\n  // 将顶点着色器的顶点传到片元着色器上\n  // 将顶点着色器的position传到common定义的varying vposition，这样在片元着色器能获取到顶点着色器的position\n  `#include <begin_vertex>\n      vPosition = position;\n      `);\n  shader.fragmentShader = shader.fragmentShader.replace('#include <common>',\n  // 将材质传入的变量定义，将顶点传入的数据定义\n  `#include <common>\n        uniform vec3 uTopColor;\n        uniform float uHeight;\n        varying vec3 vPosition;\n        `);\n  shader.fragmentShader = shader.fragmentShader.replace('// #end#',\n  // 定义一个将要混合成的颜色变量，将片元着色器的颜色传入\n  `\n        vec4 distGradColor = gl_FragColor;\n        // 设置混合百分比 uHeight 的差可能为负，所以永远为正 -84 + 84 必须等于 0 到 160   即 负除正等于 负乘正\n        float gradMix = (vPosition.y + uHeight / 2.0) / uHeight; // 从0到高度  即从0到100%\n        // 计算混合颜色\n        vec3 gradMixColor = mix(distGradColor.xyz, uTopColor, gradMix);\n        gl_FragColor = vec4(gradMixColor, 1);\n        // #end#\n        `);\n}\n\n// 2.扩散效果\nfunction addSpread(shader) {\n  // 传入扩散中心点\n  shader.uniforms.uSpreadCenter = {\n    value: new THREE.Vector2(0, 0)\n  };\n  // 传入扩散时间\n  shader.uniforms.uSpreadTime = {\n    value: 0\n  };\n  // 传入条纹的宽度\n  shader.uniforms.uSpreadWidth = {\n    value: 30\n  };\n  shader.fragmentShader = shader.fragmentShader.replace('#include <common>',\n  // 将材质传入的变量定义，将顶点传入的数据定义\n  `#include <common>\n        uniform vec2 uSpreadCenter;\n        uniform float uSpreadTime;\n        uniform float uSpreadWidth;\n        `);\n  shader.fragmentShader = shader.fragmentShader.replace('// #end#', `\n        // 获得顶点到中心，即半径\n        float spreadRadius = distance(vPosition.xz, uSpreadCenter);\n        // 扩散范围的函数 -x的平方\n        float spreadIndex = - (spreadRadius - uSpreadTime) * (spreadRadius - uSpreadTime) + uSpreadWidth;\n        \n\n        if(spreadIndex > 0.0) {\n          gl_FragColor = mix(gl_FragColor, vec4(1, 1, 1, 1), spreadIndex / uSpreadWidth);\n        }\n        // #end#\n        `);\n  // 利用动画来让时间不断改变\n  gsap.to(shader.uniforms.uSpreadTime, {\n    value: 600,\n    duration: 1.5,\n    ease: 'none',\n    repeat: -1\n  });\n}\n\n// 3.倾斜扫描效果\nfunction addLightLine(shader) {\n  // // 传入扩散中心点\n  // shader.uniforms.uSpreadCenter = {value: new THREE.Vector2(0, 0)}\n  // 传入扩散时间\n  shader.uniforms.uLightLineTime = {\n    value: 0\n  };\n  // 传入条纹的宽度\n  shader.uniforms.uSpreadWidth = {\n    value: 30\n  };\n  shader.fragmentShader = shader.fragmentShader.replace('#include <common>',\n  // 将材质传入的变量定义，将顶点传入的数据定义\n  `#include <common>\n        uniform vec2 uSpreadCenter;\n        uniform float uSpreadTime;\n        uniform float uSpreadWidth;\n        `);\n  shader.fragmentShader = shader.fragmentShader.replace('// #end#', `\n        // 获得顶点到中心，即半径\n        float spreadRadius = distance(vPosition.xz, uSpreadCenter);\n        // 扩散范围的函数 -x的平方\n        float spreadIndex = - (spreadRadius - uSpreadTime) * (spreadRadius - uSpreadTime) + uSpreadWidth;\n        \n\n        if(spreadIndex > 0.0) {\n          gl_FragColor = mix(gl_FragColor, vec4(1, 1, 1, 1), spreadIndex / uSpreadWidth);\n        }\n        // #end#\n        `);\n  // 利用动画来让时间不断改变\n  gsap.to(shader.uniforms.uSpreadTime, {\n    value: 600,\n    duration: 1.5,\n    ease: 'none',\n    repeat: -1\n  });\n}","map":{"version":3,"names":["THREE","gsap","modityCityMaterial","city","material","onBeforeCompile","shader","fragmentShader","replace","addGradColor","addSpread","addLightLine","geometry","computeBoundingBox","max","min","boundingBox","uHeight","y","uniforms","uTopColor","value","Color","vertexShader","uSpreadCenter","Vector2","uSpreadTime","uSpreadWidth","to","duration","ease","repeat","uLightLineTime"],"sources":["D:/vscodeDemo/threeDemo/threejs_smartcity/src/threeModal/modity/modityCityMaterial.js"],"sourcesContent":["import * as THREE from 'three'\r\nimport gsap from 'gsap'\r\n// 城市模型材质修改\r\nexport default function modityCityMaterial (city) {\r\n  \r\n  // 修改城市模型着色器\r\n  city.material.onBeforeCompile = shader => {\r\n    // 添加一个替换标识\r\n    shader.fragmentShader = shader.fragmentShader.replace(\r\n      '#include <dithering_fragment>',\r\n      `#include <dithering_fragment>\r\n          // #end#\r\n          `\r\n    )\r\n    // 城市混合颜色效果\r\n    addGradColor(city, shader)\r\n    // 光圈扩散\r\n    addSpread(shader)\r\n    // 斜光线扩散\r\n    addLightLine(shader)\r\n  }\r\n}\r\n// 1.城市混合颜色效果\r\nfunction addGradColor(city, shader) {\r\n  // 先计算\r\n  city.geometry.computeBoundingBox()\r\n  // 解构得到外边界矩形\r\n  let { max, min } = city.geometry.boundingBox\r\n  // 最高点减去最低点得到高度差\r\n  let uHeight = max.y - min.y\r\n  // 最高点的颜色\r\n  shader.uniforms.uTopColor = {value: new THREE.Color('#6699cc')}\r\n\r\n  // 高度差\r\n  shader.uniforms.uHeight = {value: uHeight}\r\n  shader.vertexShader = shader.vertexShader.replace(\r\n    '#include <common>', // 将顶点着色器的顶点传到片元着色器上\r\n    // 这里定义一个属性，片元着色器才能获取\r\n    `#include <common>\r\n      varying vec3 vPosition; \r\n    `\r\n  )\r\n  shader.vertexShader = shader.vertexShader.replace(\r\n    '#include <begin_vertex>', // 将顶点着色器的顶点传到片元着色器上\r\n    // 将顶点着色器的position传到common定义的varying vposition，这样在片元着色器能获取到顶点着色器的position\r\n    `#include <begin_vertex>\r\n      vPosition = position;\r\n      `\r\n  )\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '#include <common>',\r\n    // 将材质传入的变量定义，将顶点传入的数据定义\r\n    `#include <common>\r\n        uniform vec3 uTopColor;\r\n        uniform float uHeight;\r\n        varying vec3 vPosition;\r\n        `\r\n  )\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '// #end#',\r\n    // 定义一个将要混合成的颜色变量，将片元着色器的颜色传入\r\n    `\r\n        vec4 distGradColor = gl_FragColor;\r\n        // 设置混合百分比 uHeight 的差可能为负，所以永远为正 -84 + 84 必须等于 0 到 160   即 负除正等于 负乘正\r\n        float gradMix = (vPosition.y + uHeight / 2.0) / uHeight; // 从0到高度  即从0到100%\r\n        // 计算混合颜色\r\n        vec3 gradMixColor = mix(distGradColor.xyz, uTopColor, gradMix);\r\n        gl_FragColor = vec4(gradMixColor, 1);\r\n        // #end#\r\n        `\r\n  )\r\n}\r\n\r\n// 2.扩散效果\r\nfunction addSpread(shader) {\r\n  // 传入扩散中心点\r\n  shader.uniforms.uSpreadCenter = {value: new THREE.Vector2(0, 0)}\r\n  // 传入扩散时间\r\n  shader.uniforms.uSpreadTime = {value: 0}\r\n  // 传入条纹的宽度\r\n  shader.uniforms.uSpreadWidth = {value: 30}\r\n\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '#include <common>',\r\n    // 将材质传入的变量定义，将顶点传入的数据定义\r\n    `#include <common>\r\n        uniform vec2 uSpreadCenter;\r\n        uniform float uSpreadTime;\r\n        uniform float uSpreadWidth;\r\n        `\r\n  )\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '// #end#',\r\n    `\r\n        // 获得顶点到中心，即半径\r\n        float spreadRadius = distance(vPosition.xz, uSpreadCenter);\r\n        // 扩散范围的函数 -x的平方\r\n        float spreadIndex = - (spreadRadius - uSpreadTime) * (spreadRadius - uSpreadTime) + uSpreadWidth;\r\n        \r\n\r\n        if(spreadIndex > 0.0) {\r\n          gl_FragColor = mix(gl_FragColor, vec4(1, 1, 1, 1), spreadIndex / uSpreadWidth);\r\n        }\r\n        // #end#\r\n        `\r\n  )\r\n  // 利用动画来让时间不断改变\r\n  gsap.to(shader.uniforms.uSpreadTime, {\r\n    value: 600,\r\n    duration: 1.5,\r\n    ease: 'none',\r\n    repeat: -1\r\n  })\r\n}\r\n\r\n// 3.倾斜扫描效果\r\nfunction addLightLine(shader) {\r\n  // // 传入扩散中心点\r\n  // shader.uniforms.uSpreadCenter = {value: new THREE.Vector2(0, 0)}\r\n  // 传入扩散时间\r\n  shader.uniforms.uLightLineTime = {value: 0}\r\n  // 传入条纹的宽度\r\n  shader.uniforms.uSpreadWidth = {value: 30}\r\n\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '#include <common>',\r\n    // 将材质传入的变量定义，将顶点传入的数据定义\r\n    `#include <common>\r\n        uniform vec2 uSpreadCenter;\r\n        uniform float uSpreadTime;\r\n        uniform float uSpreadWidth;\r\n        `\r\n  )\r\n  shader.fragmentShader = shader.fragmentShader.replace(\r\n    '// #end#',\r\n    `\r\n        // 获得顶点到中心，即半径\r\n        float spreadRadius = distance(vPosition.xz, uSpreadCenter);\r\n        // 扩散范围的函数 -x的平方\r\n        float spreadIndex = - (spreadRadius - uSpreadTime) * (spreadRadius - uSpreadTime) + uSpreadWidth;\r\n        \r\n\r\n        if(spreadIndex > 0.0) {\r\n          gl_FragColor = mix(gl_FragColor, vec4(1, 1, 1, 1), spreadIndex / uSpreadWidth);\r\n        }\r\n        // #end#\r\n        `\r\n  )\r\n  // 利用动画来让时间不断改变\r\n  gsap.to(shader.uniforms.uSpreadTime, {\r\n    value: 600,\r\n    duration: 1.5,\r\n    ease: 'none',\r\n    repeat: -1\r\n  })\r\n\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}